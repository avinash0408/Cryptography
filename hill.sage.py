

# This file was *autogenerated* from the file hill.sage
from sage.all_cmdline import *   # import sage library

_sage_const_97 = Integer(97); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_9 = Integer(9); _sage_const_11 = Integer(11); _sage_const_15 = Integer(15); _sage_const_17 = Integer(17); _sage_const_19 = Integer(19); _sage_const_21 = Integer(21); _sage_const_23 = Integer(23); _sage_const_25 = Integer(25); _sage_const_13 = Integer(13); _sage_const_4 = Integer(4); _sage_const_6 = Integer(6); _sage_const_2 = Integer(2); _sage_const_14 = Integer(14); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_26 = Integer(26); _sage_const_16 = Integer(16); _sage_const_36 = Integer(36); _sage_const_49 = Integer(49); _sage_const_64 = Integer(64); _sage_const_81 = Integer(81); _sage_const_100 = Integer(100); _sage_const_0p5 = RealNumber('0.5')
import numpy as np
import math
alpha="abcdefghijklmnopqrstuvwxyz"
alpha_map={x:ord(x)-_sage_const_97  for x in alpha}
accept=[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_9 ,_sage_const_11 ,_sage_const_15 ,_sage_const_17 ,_sage_const_19 ,_sage_const_21 ,_sage_const_23 ,_sage_const_25 ]
inverse={_sage_const_1 :_sage_const_1 ,_sage_const_3 :_sage_const_9 ,_sage_const_5 :_sage_const_21 ,_sage_const_7 :_sage_const_15 ,_sage_const_9 :_sage_const_3 ,_sage_const_11 :_sage_const_19 ,_sage_const_15 :_sage_const_7 ,_sage_const_17 :_sage_const_23 ,_sage_const_19 :_sage_const_11 ,_sage_const_21 :_sage_const_5 ,
_sage_const_23 :_sage_const_17 ,_sage_const_25 :_sage_const_25 }

def encrypt(plain_text):
    plain_text=plain_text.lower()
    key=[[_sage_const_9 ,_sage_const_7 ,_sage_const_11 ,_sage_const_13 ],[_sage_const_4 ,_sage_const_7 ,_sage_const_5 ,_sage_const_6 ],[_sage_const_2 ,_sage_const_21 ,_sage_const_14 ,_sage_const_9 ],[_sage_const_3 ,_sage_const_23 ,_sage_const_21 ,_sage_const_8 ]]
    print(key)
    plain_text=plain_text.replace(" ","")
    if(len(plain_text)%len(key)!=_sage_const_0 ):
        x=len(key)-(len(plain_text)%len(key))
        plain_text=plain_text+x*'z'

    plain=[]
    li=[]
    i=_sage_const_0 
    while(i<len(plain_text)):
        if(plain_text[i]!=" "):
            if(i!=_sage_const_0  and i%len(key)==_sage_const_0 ):
                plain.append(li)
                li=[]
            li.append(alpha_map[plain_text[i]])
        i+=_sage_const_1 
    plain.append(li)
    ans=np.matmul(plain,key)%_sage_const_26 
    cipher=""
    for j in ans:
        for k in j:
            cipher=cipher+chr(k+_sage_const_97 )
    return cipher

def decrypt(cipher,key):
    revert=""
    mod_inv=modular_mat_inverse(key)
    cipher_mat=[]
    li=[]
    i=_sage_const_0 
    while(i<len(cipher)):
        if(i!=_sage_const_0  and i%len(key)==_sage_const_0 ):
                cipher_mat.append(li)
                li=[]
        li.append(alpha_map[cipher[i]])
        i+=_sage_const_1 
    cipher_mat.append(li)
    ans=np.matmul(cipher_mat,mod_inv)%_sage_const_26 
    for j in ans:
        for k in j:
            revert=revert+chr(k+_sage_const_97 )

    
    return revert
def modular_mat_inverse(key):
    name=Matrix(key)
    inv=name.inverse()
    return inv%_sage_const_26 

def bob_decrypt(cipher):
    key=[[_sage_const_9 ,_sage_const_7 ,_sage_const_11 ,_sage_const_13 ],[_sage_const_4 ,_sage_const_7 ,_sage_const_5 ,_sage_const_6 ],[_sage_const_2 ,_sage_const_21 ,_sage_const_14 ,_sage_const_9 ],[_sage_const_3 ,_sage_const_23 ,_sage_const_21 ,_sage_const_8 ]]
    revert=""
    mod_inv=modular_mat_inverse(key)
    cipher_mat=[]
    li=[]
    i=_sage_const_0 
    while(i<len(cipher)):
        if(i!=_sage_const_0  and i%len(key)==_sage_const_0 ):
                cipher_mat.append(li)
                li=[]
        li.append(alpha_map[cipher[i]])
        i+=_sage_const_1 
    cipher_mat.append(li)
    ans=np.matmul(cipher_mat,mod_inv)%_sage_const_26 
    for j in ans:
        for k in j:
            revert=revert+chr(k+_sage_const_97 )

    
    return revert
# def known_cipher(cipher): 
#     maxi=0
#     curr=""
#     for i in accept:
#         de=""
#         for j in range(26):
#             de=decrypt(cipher,i,j)
#             p=check(de)
#             if(p>maxi):
#                 maxi=p
#                 curr=de

#     return curr
 
def known_plaintext(cipher):
    li=[_sage_const_4 ,_sage_const_9 ,_sage_const_16 ,_sage_const_25 ,_sage_const_36 ,_sage_const_49 ,_sage_const_64 ,_sage_const_81 ,_sage_const_100 ]
    kplain="jhlnehfgcvojdxvi".lower()
    kcipher="ospyoipfbmsmdbmo"
    kplain=kplain.replace(" ","")
    ci_len=len(kcipher)
    kplain=kplain+'z'*(ci_len-len(kplain))
    req=_sage_const_4 
    if ci_len in li:
        req=int(ci_len**_sage_const_0p5 )
    plain=[]
    ci=[]
    li_c=[]
    li=[]
    i=_sage_const_0 
    while(i<len(kplain)):
            if(i!=_sage_const_0  and i%req==_sage_const_0 ):
                plain.append(li)
                ci.append(li_c)
                li=[]
                li_c=[]
            li.append(alpha_map[kplain[i]])
            li_c.append(alpha_map[kcipher[i]])
            i+=_sage_const_1 
    plain.append(li)
    ci.append(li_c)
    print(plain)
    plain_inv=modular_mat_inverse(plain)
    print(plain_inv)
    key=np.matmul(plain_inv,ci)%_sage_const_26 

    return decrypt(cipher,key)




    

if __name__ == "__main__":
    plain_text=input("Enter text to encrypt :\n")
    cipher=encrypt(plain_text)
    print("Encrypted text is:" +cipher)
    r1=known_plaintext(cipher)
    print("Decrypted text using known-plaintext attack is: " +r1)
    # r2=choosen_plaintext(cipher)
    # print("Decrypted text using choosen-plaintext attack is: " +r2)
    # r3=choosen_cipher(cipher)
    # print("Decrypted text using choosen-cipher attack is: " +r3)
    # r4=known_cipher(cipher)
    # print("Decrypted text using known-cipher attack is: " +r4)
    
   
        




    
 

